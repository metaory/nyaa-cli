#!/usr/bin/env bash
set -euo pipefail
set -E
set -o errtrace

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ DEFAULTS ]
BASE_URL="https://nyaa.si"
QUALITY="720"
CAT="1_2"
PAGE=1
FROM=
TO=
NAME=
UPLOADER=
TMP=./dev
typeset -gA list=()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ LOG ]
function log {
    local level="${1:-info}"
    shift
    local color=""
    local prefix=""
    case "$level" in
    error) color="\033[1;31m"; prefix="âŒ" ;;
    warn) color="\033[1;33m"; prefix="âš ï¸" ;;
    info) color="\033[1;34m"; prefix="â„¹ï¸" ;;
    success) color="\033[1;32m"; prefix="âœ“" ;;
    hint) color="\033[1;36m"; prefix="ðŸ’¡" ;;
    episode) color="\033[1;35m"; prefix="ðŸŽ¬" ;;
    fetch) color="\033[1;33m"; prefix="ðŸ”" ;;
    *) color=""; prefix="" ;;
    esac
    printf '%b%s %s%b\n' "$color" "$prefix" "$*" "\033[0m" >&2
}

function highlight {
    printf '\033[1;97m%s\033[0m' "$1"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ ERROR HANDLING ]
function on_error {
    local exit_code=$?
    local line_no=$1
    local cmd=$2
    log error "ERROR at line $line_no: $cmd (exit $exit_code)"
}

function cleanup {
    log info "Cleaning up..."
    # rm -rf "$TMP"
}

trap 'on_error $LINENO "$BASH_COMMAND"' ERR
trap cleanup EXIT
trap 'log warn "Interrupted"; cleanup; exit 1' INT

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ STATE ]
STATE_DIR="$HOME/.local/state/nyaa-cli"
STATE_FILE="$STATE_DIR/progress"

mkdir -p "$STATE_DIR" &>/dev/null
touch "$STATE_FILE"

function get_last_episode {
    local name="$1"
    grep "^$name" "$STATE_FILE" | cut -f2 || true
}

function update_state {
    local name="$1"
    local episode="$2"
    
    awk -v name="$name" -v ep="$episode" '
        $1 == name { next }
        { print }
        END { printf "%s\t%s\n", name, ep }
    ' "$STATE_FILE" > "$STATE_FILE.new" && mv "$STATE_FILE.new" "$STATE_FILE"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ CORE ]
function get_episodes {
    local ep="$1"
    local url="${BASE_URL}/?c=${CAT}&s=seeders&o=desc&p=${PAGE}&q=${QUALITY}+${UPLOADER}+${NAME}+${ep}"
    log fetch "Episode $ep"
    curl -s "${url}" |
        pup 'tr.success json{}' |
        jq '[.[] | {
            name: .children[1].children[0].title, 
            size: .children[3].text, 
            date: .children[4].text, 
            seeds: .children[5].text, 
            torrent_url: .children[2].children[0].href
        }]'
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ ACCUMULATE ]
function accumulate_episodes {
    local ep="$1"
    log episode "Processing Episode $(highlight "$ep")"
    local results
    results=$(get_episodes "$ep")
    local count
    count=$(echo "$results" | jq 'length')
    if [[ "$count" -eq 0 ]]; then
        log warn "No results found for episode $ep"
        return
    fi
    local top
    top=$(echo "$results" | jq '.[0]')
    local torrent_url
    torrent_url=$(echo "$top" | jq -r '.torrent_url')
    list[$ep]="$torrent_url"
    log success "Found: $(highlight "$torrent_url")"
    update_state "$NAME" "$ep"
    if [[ -n "$TO" && $ep -ge $TO ]]; then
        log info "Reached target episode $TO"
        return
    fi
    printf '\n' >&2
    accumulate_episodes $((ep + 1))
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ CLI ]
function usage {
    cat <<EOF
nyaa-cli :: Download episodes in bulk from nyaa.si

Usage:
  nyaa-cli --name "one piece" --episode 120
  nyaa-cli --name "one piece" --from 120 [--to 130]
  nyaa-cli --name "one piece" --episode 120 --uploader "Erai"
  nyaa-cli --name "one piece" --from 120 --quality "720"

Options:
  --name      Anime name (required)
  --episode   Episode number (exclusive with --from)
  --from      Starting episode (exclusive with --episode)
  --to        Ending episode (optional, with --from)
  --quality   Video quality (default: 720)
  --uploader  Uploader filter (e.g. Erai, SubsPlease)

Notes:
  --from and --episode can't be used together.
  --from without --to downloads all episodes from start.
  Not specifying --uploader picks highest seeder.

EOF
}

while [[ $# -gt 0 ]]; do
    case "$1" in
    --help | -h)
        usage
        exit 0
        ;;
    --episode)
        FROM="$2"
        TO="$2"
        shift 2
        ;;
    --from)
        FROM="$2"
        shift 2
        ;;
    --to)
        TO="$2"
        shift 2
        ;;
    --quality)
        QUALITY="$2"
        shift 2
        ;;
    --name)
        NAME="${2// /+}"
        shift 2
        ;;
    --uploader)
        UPLOADER="$2"
        shift 2
        ;;
    *)
        log error "unknown arg: $1"
        usage
        exit 1
        ;;
    esac
done

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ VALIDATION ]
# Ensure Bash 5.0+ is installed
if [ -z "$BASH_VERSION" ] || [ "${BASH_VERSINFO[0]}" -lt 5 ]; then
    log error "âŒ Bash 5.0+ required. On macOS, install with Homebrew: brew install bash"
    log error "Then run: /opt/homebrew/bin/bash ./nyaa-cli ..."
    exit 127
fi

# Ensure --name is provided
if [[ -z "$NAME" ]]; then
    log error "--name is required"
    usage
    exit 1
fi

# --to can only be present if --from is present
if [[ -n "$TO" && -z "$FROM" ]]; then
    log error "--to can only be used with --from"
    usage
    exit 1
fi

# If --from is not specified, use state file
if [[ -z "$FROM" ]]; then
    last_ep=$(get_last_episode "$NAME")
    if [[ -z "$last_ep" ]]; then
        log info "No previous episodes found for $NAME, starting from episode 1"
        FROM=1
    else
        log info "Found last episode $last_ep for $NAME in state file"
        FROM=$((last_ep + 1))  # Start from next episode
    fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ REQUIREMENTS ]
command -v pup >/dev/null 2>&1 || {
    log info "installing pup..."
    command -v go >/dev/null 2>&1 || {
        log error 'Go not found. Please install Go.'
        exit 1
    }
    go install github.com/ericchiang/pup@latest
    sudo mv ~/go/bin/pup /usr/local/bin/
}

for cmd in jq curl pup; do
    command -v "$cmd" >/dev/null || {
        log error "missing: $cmd"
        exit 127
    }
done

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ UI ]
logheader() {
    printf '\n\033[1;36mâ•­â”€[ SETUP ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•´â”€â”€â”€â•¶â•´â”€â”€â•¶â•´â•´\033[0m\n'
    for var; do
        printf '\033[1;36mâ”‚\033[0m %-12s : \033[1m%s\033[0m\n' "$var" "${!var}"
    done
    printf '\033[1;36mâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•´â”€â•´â”€â•´â•´â•´â•´\033[0m\n'
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ DRIVER ]
logheader QUALITY UPLOADER NAME FROM TO TMP

log info "Starting download from episode $(highlight "$FROM")${TO:+ to $(highlight "$TO")}"
printf '\n' >&2
accumulate_episodes "$FROM"
printf '\n' >&2
log success "Download complete. Found $(highlight "${#list[@]}") episodes:"
for ep in "${!list[@]}"; do
    printf '  %s: %s\n' "$(highlight "$ep")" "${list[$ep]}"
done

###